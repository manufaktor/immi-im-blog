# Using UUIDs in SQLite

SQLite does not support UUID's by default, but with a bit of tweaking it is certainly possible. I'll explain how to bring UUIDs to SQLite and how to use them as as primary keys for a table - with all the small steps it took me to get there.

## Why use UUIDs?

I recently had the idea to shard some data over multiple SQLite databases, but still run analytical queries accross all databases. As an example, think one database per customer, but one big offline database to figure out how many blog posts were written per user. To do that, I need to merge some tables in one big database, which is easy enough when all databases share the same schema. However, having autoincrementing integer primary keys would lead to conflicts when merging the data, since each database would have the same incrementing IDs. A bit of an annoyance.

Using UUID primary keys could help, because they are unique accross all databases. They take a bit more space than just integers, but this doesn't concern us now.

## Getting started (on Mac OS)

While researching the topic, I discovered this entry in the SQLite changelog:

```txt
2020-01-22 (3.31.0):
- Added the uuid.c extension module implementing functions for processing RFC-4122 UUIDs.
```

The [extension](https://sqlite.org/src/file/ext/misc/uuid.c) mentions a `uuid()` function in SQLite. But because the pre-installed version of SQLite on Mac OS is pretty outdated, we first need to install a more current version.

```sh
brew install sqlite
```

Homebrew recognizes that SQLite is already preinstalled and doesn't override the existing sqlite3 binary. Instead, you'll have to call it by it's real name:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3 # You can figure out this path via `brew info sqlite`

SQLite version 3.34.0 2020-12-01 16:14:00
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>

```

## How to install an SQLite extension

Let's see if we can use this `uuid()` function:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3

sqlite > select uuid(); # Error: no such function: uuid
```

This doesn't work, because 3.31.0 just includes the source for the UUID extension, but it's not part of any build. So let's change this by getting the [source code](https://sqlite.org/src/file/ext/misc/uuid.c) first.

Once we've downloaded the source file, we need to compile the extension, using `gcc`:

```sh
# passing my brew-installed version of sqlite to be included in the search path
gcc -g -fPIC -I /usr/local/opt/sqlite/include -dynamiclib uuid.c -o uuid.dylib
```

Now we should have a compiled the `uuid.dylib` extension, which we can load into SQLite:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3

sqlite> .load ./uuid # path to the file, omit file extension
sqlite> select uuid();
615b71a4-8109-435e-b7fe-5f9be6a77b49
```

Nice, we've accomplished something! Now we can start using `uuid()` during our open SQLite session. This is not a permanent install of the extension, though. The next time you open the sqlite shell, you need to run `.load ./uuid` again.

The same thing applies when connecting to SQLite from an application, say, in Ruby, but I'll leave the details for another blog post.

## Creating UUID primary keys

Unlike in Postgres, we don't really have a `uuid` datatype. What we have now is a function to generate a version 4 UUID as a string (technically you also need to load an extension, `uuid-ossp` in Postgres to have functions to generate them). We can either store them as strings or blobs. The later will use only 16-bytes per UUID and save some space in the long run, the former is a bit easier to work with.

```sql
select uuid_blob(uuid());
/* > n??KB?E?? ??I? # This is the binary UUID */
```

And of course we can also convert the binary UUID back using `uuid_str()`, since readability is a bit challenged when printing binary.

```sql
select uuid_str(uuid_blob(uuid()));
/* > 43c734ce-c533-4e9e-acce-367735915e86 # 'tis a string now  */
```

Finally, let's create a table using `uuid()` for the primary key and see if we can insert some records:

```sql
create table posts(
  id blob primary key default (uuid_blob(uuid())),
  body text
) without rowid;
/* `without rowid` enforces not null on the primary key,
and will omit the default rowid generated by sqlite */

insert into posts(body) values('I am blog');

select uuid_str(id), body from posts;
> 7da0322e-12f5-453f-8695-85e00bafc590|I am blog
```

Having to use `uuid_str()` when reading back the binary uuid is a bit annoying, so I might just use strings for ease of use. Apart from that, nice! We have successfully employed UUID primary keys in SQLite.
