# Using UUIDs in SQLite

I recently had the idea to shard some data over multiple SQLite databases, but still run analytical queries accross all databases. To do that, I need to merge some tables in one big database, which is easy enough when all databases share the same schema. However, having serial, autoincrementing primary keys would lead to conflicts when merging the data. A bit of an annoyance.

## UUID to the rescue

Using UUID primary keys can help, they are unique accross all databases. They take a bit more space than just integers, but this doesn't concern us yet. Unfortunately, SQLite doesn't support UUID's out of the box, but I found a notable entry in the changelog:

```txt
2020-01-22 (3.31.0):
- Added the uuid.c extension module implementing functions for processing RFC-4122 UUIDs.
```

## Testing it on Mac OS

The [extension](https://sqlite.org/src/file/ext/misc/uuid.c) mentions a `uuid()` function in SQLite. But because the pre-installed version of SQLite on Mac OS is pretty outdated, we first need to install a more current version.

```sh
brew install sqlite
```

Homebrew recognizes that SQLite is already preinstalled and doesn't override the existing sqlite3 binary. Instead, you'll have to call it by it's real name:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3 # You can figure out this path via `brew info sqlite`

SQLite version 3.34.0 2020-12-01 16:14:00
Enter ".help" for usage hints.
Connected to a transient in-memory database.
Use ".open FILENAME" to reopen on a persistent database.
sqlite>

```

## How to install an SQLite extension

Let's see if we can use this `uuid()` function:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3

sqlite > select uuid(); # Error: no such function: uuid
```

This doesn't work, because 3.31.0 just includes the source for the UUID extension, but it's not part of any build. So let's change this by getting the [source code](https://sqlite.org/src/file/ext/misc/uuid.c) first.

Once we've downloaded the source file, we need to compile the extension, using `gcc`:

```sh
# passing my brew-installed version of sqlite to be included in the search path
gcc -g -fPIC -I /usr/local/opt/sqlite/include -dynamiclib uuid.c -o uuid.dylib
```

Now we should have a compiled the `uuid.dylib` extension, which we can load into SQLite:

```sh
$ /usr/local/opt/sqlite3/bin/sqlite3

sqlite> .load ./uuid # path to the file, omit file extension
sqlite> select uuid();
615b71a4-8109-435e-b7fe-5f9be6a77b49
```

Nice, we've accomplished something! Now we can start using `uuid()` during our open SQLite session. This is not a permanent install of the extension, though. The next time you open the sqlite shell, you need to run `.load uuid` again.

The same thing applies when connecting to SQLite from an application, say, in Ruby, but I'll leave the details for another blog post.

## Using a UUID as primary key

Unlike in Postgres, we don't really have a `uuid` datatype. What we have is a function to generate a version 4 UUID as a string. We can either store it as string, or as blob. The later will use only 16-bytes per UUID and save some space in the long run, the former is a bit easier to work with.

```sql
select uuid_blob(uuid());
> n??KB?E?? ??I? /* This is the binary UUID */
```

And of course we can also convert the blob back using `uuid_str()`, since readability is a bit challenged when printing binary.

```sql
select uuid_str(uuid_blob(uuid()));
> 43c734ce-c533-4e9e-acce-367735915e86 /* 'tis a string now */
```

Finally, let's create a table using `uuid()` as a primary key and see if we can insert some records:

```sql
create table posts(
  id blob primary key default (uuid_blob(uuid())),
  body text
) without rowid;
/* `without rowid` enforces not null on the primary key,
and will omit the default rowid generated by sqlite */

insert into posts(body) values('I am blog');

select uuid_str(id), body from posts;
> 7da0322e-12f5-453f-8695-85e00bafc590|I am blog
```

Having to use `uuid_str()` when reading back the binary uuid is a bit annoying, so I might just use strings for ease of use. Apart from that, nice! We have successfully employed UUID primary keys in SQLite.
